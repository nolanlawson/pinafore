<div class="compose-box-button-sentinel" ref:sentinel></div>
<div class="{computedClass}"
     ref:wrapper >
  <ComposeButton {overLimit} {sticky} on:click="onClickButton()" />
</div>
<style>
  .compose-box-button-wrapper {
    /*
     * We want pointer-events only for the sticky button, so use fit-content so that
     * the element doesn't take up the full width, and then set its left margin to
     * auto so that it sticks to the right. fit-content doesn't work in Edge, but
     * that just means that content that is level with the button is not clickable.
     */
    width: -moz-fit-content;
    width: fit-content;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
  }

  .compose-box-button-sticky {
    position: -webkit-sticky;
    position: sticky;
  }

  :global(.compose-box-button-sticky, .compose-box-button-fixed) {
    z-index: 5000;
    top: calc(var(--main-content-pad-top) + var(--sticky-pad-top));
  }

  .compose-box-button-sticky.ios-workaround {
    /* see https://github.com/nolanlawson/pinafore/issues/667 */
    position: relative;
    z-index: 0;
    top: 0;
  }
</style>
<script>
  import ComposeButton from './ComposeButton.html'
  import { store } from '../../_store/store'
  import { importShowComposeDialog } from '../dialog/asyncDialogs'
  import { observe } from 'svelte-extras'
  import { isIOSPre13 } from '../../_utils/userAgent'
  import { classname } from '../../_utils/classname'

  export default {
    oncreate () {
      this.setupIntersectionObservers()
      this.setupIOSWorkaround()
    },
    ondestroy () {
      this.teardownIntersectionObservers()
    },
    store: () => store,
    data: () => ({
      sticky: false,
      iosWorkaround: false /* isIOSPre13() */
    }),
    computed: {
      timelineInitialized: ({ $timelineInitialized }) => $timelineInitialized,
      computedClass: ({ showSticky, hideAndFadeIn, iosWorkaround }) => (classname(
        'compose-box-button-wrapper',
        showSticky && 'compose-box-button-sticky',
        hideAndFadeIn,
        iosWorkaround && 'ios-workaround'
      ))
    },
    methods: {
      observe,
      onClickButton () {
        const { sticky } = this.get()
        if (sticky) {
          // when the button is sticky, we're scrolled down the home timeline,
          // so we should launch a new compose dialog
          this.showDialog()
        } else {
          // else we're actually posting a new toot, let our parent know
          this.fire('postAction')
        }
      },
      async showDialog () {
        (await importShowComposeDialog())()
      },
      setupIOSWorkaround () {
        // This is an elaborate fix for https://github.com/nolanlawson/pinafore/issues/667
        // We detect old iOS versions. Then, we set the main content element
        // to be overflow-x: hidden, which normally would break the sticky button
        // because its parent is now the scrolling context. So for iOS only, we
        // create a fake sticky button by listening to intersecting events
        // and inserting a permanently fixed-position element into the DOM.
        // This bug seems fixed in iOS 13 so it's only enabled for older iOS versions.
        const { showSticky, iosWorkaround } = this.get()
        if (!iosWorkaround || !showSticky) {
          return
        }

        const cleanup = () => {
          const existingElement = document.getElementById('the-sticky-button')
          if (existingElement) {
            document.body.removeChild(existingElement)
          }
          if (this.__fixedStickyButton) {
            this.__fixedStickyButton.destroy()
            this.__fixedStickyButton = null
          }
        }

        const createFixedStickyButton = () => {
          const element = document.createElement('div')
          element.setAttribute('id', 'the-sticky-button')
          element.classList.add('compose-box-button-wrapper')
          element.classList.add('compose-box-button-fixed')
          document.body.appendChild(element)
          const rect = this.refs.wrapper.getBoundingClientRect()
          Object.assign(element.style, {
            left: `${rect.left}px`,
            position: 'fixed'
          })
          this.__fixedStickyButton = new ComposeButton({
            target: element,
            data: {
              sticky: true,
              overLimit: false
            }
          })
          this.__fixedStickyButton.on('click', () => this.showDialog())
        }

        this.observe('sticky', sticky => {
          cleanup()
          if (sticky) {
            createFixedStickyButton()
          }
        })
        this.on('destroy', () => cleanup())
      },
      setupIntersectionObservers () {
        const sentinel = this.refs.sentinel

        this.__stickyObserver = new IntersectionObserver(entries => this.onObserve(entries))
        this.__stickyObserver.observe(sentinel)

        // also create a one-shot observer for the $timelineInitialized event,
        // due to a bug in Firefox where when the scrollTop is set
        // manually, the other observer doesn't necessarily fire
        this.observe('timelineInitialized', timelineInitialized => {
          if (timelineInitialized && !this.__oneShotObserver) {
            this.__oneShotObserver = new IntersectionObserver(entries => {
              this.onObserve(entries)
              this.__oneShotObserver.disconnect()
              this.__oneShotObserver = null
            })
            this.__oneShotObserver.observe(sentinel)
          }
        }, { init: false })
      },
      onObserve (entries) {
        this.set({ sticky: !entries[0].isIntersecting })
      },
      teardownIntersectionObservers () {
        if (this.__stickyObserver) {
          this.__stickyObserver.disconnect()
          this.__stickyObserver = null
        }
        if (this.__oneShotObserver) {
          this.__oneShotObserver.disconnect()
          this.__oneShotObserver = null
        }
      }
    },
    components: {
      ComposeButton
    }
  }
</script>
